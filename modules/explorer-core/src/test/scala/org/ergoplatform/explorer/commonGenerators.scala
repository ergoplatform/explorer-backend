package org.ergoplatform.explorer

import cats.instances.try_._
import eu.timepit.refined._
import eu.timepit.refined.string.HexStringSpec
import io.circe.Json
import io.estatico.newtype.ops._
import org.ergoplatform.explorer.constraints.Base58Spec
import org.scalacheck.{Arbitrary, Gen}
import scorex.crypto.hash.Blake2b256
import scorex.util.Random
import scorex.util.encode.{Base16, Base58}

import scala.util.Try

object commonGenerators {

  implicit val arbHex: Arbitrary[HexString]      = Arbitrary(hexStringRGen)
  implicit val arbAddr: Arbitrary[Address]       = Arbitrary(addressGen)
  implicit val arbJson: Arbitrary[Json]          = Arbitrary(jsonFieldsGen)
  implicit val arbId: Arbitrary[BlockId]              = Arbitrary(idGen)
  implicit val arbTxId: Arbitrary[TxId]          = Arbitrary(txIdGen)
  implicit val arbBoxId: Arbitrary[BoxId]        = Arbitrary(boxIdGen)
  implicit val arbAssetId: Arbitrary[TokenId]    = Arbitrary(assetIdGen)
  implicit val registerId: Arbitrary[RegisterId] = Arbitrary(registerIdGen)

  def hexStringGen: Gen[String] =
    Gen
      .nonEmptyListOf(Gen.alphaNumChar)
      .map(_ => Base16.encode(Blake2b256.hash(Random.randomBytes().mkString)))

  def hexStringRGen: Gen[HexString] =
    hexStringGen
      .map(x => refineV[HexStringSpec](x).right.get)
      .map(HexString.apply)

  def addressGen: Gen[Address] =
    Gen
      .nonEmptyListOf(Gen.alphaNumChar)
      .map(x => Base58.encode(Blake2b256.hash(x.mkString)))
      .map(x => refineV[Base58Spec](x).right.get)
      .map(Address.apply)

  def jsonFieldsGen: Gen[Json] =
    Gen.oneOf(
      List(
        Json.obj(
          "0x00" -> Json.fromString("fa209e"),
          "0x01" -> Json.fromString("871b"),
          "0x02" -> Json.fromString("6ac2e1c9")
        ),
        Json.Null
      )
    )

  def idGen: Gen[BlockId] =
    hexStringGen.map(x => BlockId.fromString[Try](x).get)

  def txIdGen: Gen[TxId] =
    hexStringGen.map(_.coerce[TxId])

  def boxIdGen: Gen[BoxId] =
    hexStringGen.map(_.coerce[BoxId])

  def assetIdGen: Gen[TokenId] =
    hexStringGen.map(TokenId.fromString[Try](_).get)

  def registerIdGen: Gen[RegisterId] =
    Gen.oneOf(
      List(
        RegisterId.R0,
        RegisterId.R1,
        RegisterId.R2,
        RegisterId.R3,
        RegisterId.R4,
        RegisterId.R5,
        RegisterId.R6,
        RegisterId.R7,
        RegisterId.R8,
        RegisterId.R9
      )
    )

  /** Runs a given `test` for a single sample generated by a given `gen`.
    */
  def forSingleInstance[T](gen: Gen[T])(test: T => Any): Any = {
    val numRetries = 1000
    @scala.annotation.tailrec
    def go(retries: Int): Any =
      gen.sample match {
        case Some(sample) =>
          test(sample)
        case None if retries <= numRetries =>
          go(retries + 1)
        case None =>
          throw new Exception(s"Gave up after $numRetries attempts")
      }
    go(0)
  }
}
